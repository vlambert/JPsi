/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 * PHOSPHOR Model PDF - PHOton energy Scale and PHOton energy Resolution Fit *
 * Jan Veverka, Caltech, 8 February 2012                                     *
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "JPsi/MuMu/interface/RooPhosphorPdf.h" 
#include "RooAbsReal.h" 
#include "RooAbsRealLValue.h" 
#include "RooAbsCategory.h"
#include "RooDataHist.h"
#include "RooCmdArg.h"
#include "RooHistFunc.h"
#include "TH1.h" 
#include <math.h> 
#include <string>
#include "TMath.h" 

ClassImp(RooPhosphorPdf) 

/******************************************************************************/
RooPhosphorPdf::RooPhosphorPdf(const char *name, const char *title, 
			       RooAbsReal& _mass,
			       RooAbsReal& _msubs,
			       RooRealVar& _phos,
			       RooRealVar& _phor,
			       const RooDataHist& _massPhorHist, Int_t _intOrder) :
RooHistPdf(name, title, RooArgList(_msubs, _phor), RooArgList(_mass, _phor), 
	   _massPhorHist, _intOrder),
  mass("mass","mass",this,_mass),
  msubs("msubs","msubs",this,_msubs),
  phos("phos","phos",this,_phos),
  phor("phor","phor",this,_phor),
  intOrder(_intOrder),
// cachePhos(new RooRealVar("cachePhos", "cachePhos", 0.)),
// cachePhor(new RooRealVar("cachePhor", "cachePhor", 2.)),
  cachePhos(new RooRealVar(_phos)),
  cachePhor(new RooRealVar(_phor)),
  normCache(new RooArgSet("normCache")),
  listOfNormDataHists(new TList())
{ 
  // std::cout << "Entering default RooPhosphorPdf ctor" << std::endl;
  listOfNormDataHists->SetOwner(kTRUE);
} 


/******************************************************************************/
RooPhosphorPdf::RooPhosphorPdf(const RooPhosphorPdf& other, const char* name) :  
   RooHistPdf(other,name), 
   mass("mass",this,other.mass),
   msubs("msubs",this,other.msubs),
   phos("phos",this,other.phos),
   phor("phor",this,other.phor),
   intOrder(other.intOrder),
   cachePhos(new RooRealVar(*other.cachePhos)),
   cachePhor(new RooRealVar(*other.cachePhor)),
   normCache(new RooArgSet("normCache")),
   listOfNormDataHists(new TList())
{ 
  cxcoutD(Integration) << "Entering copy RooPhosphorPdf::ctor(" << GetName()
		       << ") " << std::endl;
  // Clone the contents of the other normaliztion integral cache.
  // This is a little tricky.  The norm is implemented as a
  // RooHistFunc.  It has an internal pointer to a RooDataHist
  // data.  This data is an independent object not owned by the 
  // norm.  We have to take care to clone this data separately and
  // make the cloned norm such that it points to it.
  listOfNormDataHists->SetOwner(kTRUE);
  TIterator *normItr = other.normCache->createIterator();
  RooAbsArg *otherNorm;
  for (size_t i=0; (otherNorm = (RooAbsArg*) normItr->Next()); ++i) {
    if (!dynamic_cast<RooHistFunc*>(otherNorm)) {
      coutE(Integration) << "RooPhosphorPdf::ctor(" << GetName() 
			    << "): normalization cache element " 
			    << otherNorm->GetName() 
			    << " is not of type RooHistFunc" << std::endl;
      throw string("RooPhosphorPdf::ctor() ERROR normalization cache element "
		   "is not of type RooHistFunc") ;
    }
    RooHistFunc *otherNormFunc = dynamic_cast<RooHistFunc*>(otherNorm);
    RooDataHist const& otherNormData = otherNormFunc->dataHist();
    cxcoutD(Caching) << "RooPhosphorPdf::ctor(" << name << "): cloning cached "
		     << "norm " << otherNormFunc->GetName() << "." << std::endl;
    std::string normFuncName(otherNormFunc->GetName());
    std::string normDataName(otherNormData.GetName());
    if (strcmp(other.GetName(), name) != 0) {
      // Need to upate the names.
      normFuncName.replace(0, strlen(other.GetName()), name);
      normDataName.replace(0, strlen(other.GetName()), name);
    }
    RooDataHist *normDataClone = NULL;
    RooHistFunc *normFuncClone = NULL;
    normDataClone = (RooDataHist*) otherNormData.Clone(normDataName.c_str());
    normFuncClone = new RooHistFunc(normFuncName.c_str(), normFuncName.c_str(),
				    *(normDataClone->get()), *normDataClone,
				    other.getInterpolationOrder());
    normCache->addOwned(*normFuncClone);
    listOfNormDataHists->Add(normDataClone);
  }
  delete  normItr;
} 


/******************************************************************************/
RooPhosphorPdf::~RooPhosphorPdf()
{ 
  // std::cout << "Entering ~RooPhosporPdf" << std::endl;
  // Delete the objects in the normaliztion integral cache and the cache itself.
  normCache->removeAll();
  delete normCache;

  // Delete all the data used by the normalization integral cache.
  // listOfNormDataHists->Delete()

  // std::vector<RooDataHist*>::const_iterator normDataItr;
  // for (normDataItr = listOfNormDataHists->begin();
  //      normDataItr != listOfNormDataHists->end(); ++normDataItr) {
  //   delete *normDataItr;
  // }

  // Delete the data container.
  delete listOfNormDataHists;
  delete cachePhos;
  delete cachePhor;
}


/******************************************************************************/
Double_t RooPhosphorPdf::evaluate() const 
{ 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   return RooHistPdf::evaluate() ; 
} 



/******************************************************************************/
Int_t RooPhosphorPdf::getAnalyticalIntegral(RooArgSet& allVars, 
					    RooArgSet& analVars, 
					    const char* /*rangeName*/) const  
{ 
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE 
   // matchArgs EXPRESSION MULTIPLE TIMES

   // if (matchArgs(allVars, analVars, mass) && intOrder >= 0) return 1 ; 
   if (matchArgs(allVars, analVars, mass)) return 1 ; 
   return 0 ; 
 } 



/******************************************************************************/
Double_t 
RooPhosphorPdf::analyticalIntegral(Int_t code, const char* rangeName) const  
{ 
  // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY 
  // getAnalyticalIntegral. THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName)
  // WILL RETURN THE INTEGRATION BOUNDARIES FOR EACH OBSERVABLE x.

  if (code==1) {
    std::string normName = Form("%s_Int[%s|(%g,%g)]", GetName(), 
				mass.arg().GetName(), 
				mass.min(rangeName), mass.max(rangeName));
    RooHistFunc *norm = NULL;
    if (normCache->find(normName.c_str())) {
      // Found normalization cache for this range.
      cxcoutD(Integration) << "RooPhosphorPdf::analyticalIntegral(" 
      			    << GetName()
      			    << "): using existing " << normName
      			    << " for normalization." << std::endl;
      norm = dynamic_cast<RooHistFunc*>(normCache->find(normName.c_str()));
      if (!norm) {
	coutE(Caching) << "RooPhosphorPdf::analyticalIntegral(" << GetName()
		       << ") ERROR: norm " << normName
		       << " is not of type RooHistFunc" << std::endl;
	throw string("RooPhosphorPdf::analyticalIntegral() ERROR norm "
		     "is not of type RooHistFunc") ;
      }
    } else {
      RooAbsRealLValue const& 
	phosArg = dynamic_cast<RooAbsRealLValue const&> (phos.arg());
      RooAbsRealLValue const& 
	phorArg = dynamic_cast<RooAbsRealLValue const&> (phor.arg());

      if (!phosArg.hasBinning("normcache")) {
	coutW(Caching) << "RooPhosphorPdf::analyticalIntegral(" 
		       << GetName() << "): binning `normcache' not defined "
		       << "for " << phosArg.GetName() << "." << std::endl;
      }

      if (!phorArg.hasBinning("normcache")) {
	coutW(Caching) << "RooPhosphorPdf::analyticalIntegral(" 
		       << GetName() << "): binning `normcache' not defined "
		       << "for " << phorArg.GetName() << "." << std::endl;
      }

      coutI(Caching) << "RooPhosphorPdf::analyticalIntegral(" 
		     << GetName() << "): caching " << normName
		     << " for normalization at "
		     << phosArg.getBinning("normcache").numBins() << "x"
		     << phorArg.getBinning("normcache").numBins()
		     << " bins in (" << phosArg.GetName() << ")x("
		     << phorArg.GetName() << ")." << std::endl;

      RooHistPdf normCalcPdf(*this, Form("%s_%s", GetName(), "normCalcPdf"));
      RooAbsReal *normInt = normCalcPdf.createIntegral(RooArgSet(mass.arg()), 
						       rangeName);
      RooCmdArg bins = RooFit::Binning("normcache");
      RooCmdArg yvar = RooFit::YVar(phorArg, bins);

      TH1 *normHist = normInt->createHistogram("normHist", phosArg, bins, 
					       yvar, RooFit::Scaling(false));

      std::string normDataName = Form("%s_dataHist", normName.c_str());
      RooDataHist *
	normData = new RooDataHist(normDataName.c_str(), normDataName.c_str(),
				   RooArgList(*cachePhos, *cachePhor), 
				   normHist);

      norm = new RooHistFunc(normName.c_str(), normName.c_str(),
			     RooArgSet(*cachePhos, *cachePhor),
			     *normData, 2);

      normCache->addOwned(*norm);
      listOfNormDataHists->Add(normData);
      delete normInt;
      delete normHist;
    }
    coutI(Integration) << "RooPhosphorPdf::analyticalIntegral(" << GetName() 
		       << "): Using cached norm " << norm->GetName() 
		       << "." << std::endl;
    cachePhos->setVal(phos);
    cachePhor->setVal(phor);
    return (norm->getVal());
  } 
  return 0; 
} 

